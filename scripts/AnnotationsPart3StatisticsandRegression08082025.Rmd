---
title: "AnnotationsPart3StatisticsandRegression"
author: "Michael K. Jones"
date: "2025-07-05"
output: html_document
---

```{r}
library(data.table)

merged <- fread("/Users/mikej/Documents/Career/Georges/Ule/intron_retention_propensity/data/IR/IntronRetentionEventsAnnotatedMKJ06072025.tsv")
predict <- fread("/Users/mikej/Documents/Career/Georges/Ule/intron_retention_propensity/data/IR/Intersect_f250_CrypticPRPF8.bed")
splice <- fread("/Users/mikej/Documents/Career/Georges/Ule/intron_retention_propensity/data/IR/Intersect_f250_CrypticsNoPRPF8Overlap.bed")
```

```{r}
predict <- predict[predict[[7]] != 0, ]
library(GenomicRanges)
library(dplyr)
library(ggplot2)

# Extract strand from FullCO and insert as column 16
merged <- merged %>%
  mutate(strand = substr(FullCO, nchar(FullCO), nchar(FullCO))) %>%
  relocate(strand, .after = 15)

# Convert to GRanges
gr_merged <- GRanges(seqnames = merged$chrom,
                     ranges = IRanges(start = merged$start, end = merged$end),
                     strand = merged$strand)

gr_predict <- GRanges(seqnames = predict$V1,
                      ranges = IRanges(start = predict$V2, end = predict$V3),
                      strand = predict$V4)

# Find overlaps
hits <- findOverlaps(gr_merged, gr_predict, ignore.strand = FALSE)

# Summarise overlaps
summary_df <- as.data.frame(hits) %>%
  mutate(value = predict$V7[subjectHits]) %>%
  group_by(queryHits) %>%
  summarise(overlap_sum = sum(value, na.rm = TRUE), .groups = "drop")

# Add overlap summary back into merged, preserving all rows
merged$predict_overlap_sum <- 0  # default to 0
merged$predict_overlap_sum[summary_df$queryHits] <- summary_df$overlap_sum
merged <- merged %>%
  relocate(predict_overlap_sum, .after = 1) # relocate overlap sum to second col
```
```{r}
# Build GRanges for cryptic splice predictions that don't overlap with PRPF8 predictions
gr_splice <- GRanges(
  seqnames = splice$V1,
  ranges   = IRanges(start = splice$V2, end = splice$V3),
  strand   = splice$V6
)

# Find overlaps of merged introns vs splice predictions
hits_splice <- findOverlaps(gr_merged, gr_splice, ignore.strand = FALSE)

# Count one per splice hit, per merged intron
summary_splice_df <- as.data.frame(hits_splice) %>%
  group_by(queryHits) %>%
  summarise(splice_overlap_count = n(), .groups = "drop")

# Add back into merged, defaulting to 0
merged$splice_overlap_count <- 0
merged$splice_overlap_count[ summary_splice_df$queryHits ] <- summary_splice_df$splice_overlap_count

# Relocate for convenience (just after predict_overlap_sum)
merged <- merged %>%
  relocate(splice_overlap_count, .after = predict_overlap_sum)
```

```{r}
# Binarise PSI values
psi_mat <- as.data.frame(merged[, 37:181])
psi_mat[] <- lapply(psi_mat, function(x) as.numeric(as.character(x)))
psi_bin <- as.data.frame(lapply(psi_mat, function(x) ifelse(is.na(x), 0, ifelse(x >= 10, 1, 0))))
psi_binarised_total <- rowSums(psi_bin, na.rm = TRUE)
merged$psi_binarised_total <- psi_binarised_total

```

```{r}
# Define number of trials
merged$failures <- 145 - merged$psi_binarised_total

# Fit binomial logistic regression
fit <- glm(cbind(psi_binarised_total, failures) ~ predict_overlap_sum,
           data = merged, family = binomial)

# Create plot
ggplot(merged, aes(x = predict_overlap_sum, y = psi_binarised_total / 145)) +
  geom_jitter(width = 0.2, height = 0.02, alpha = 0.4) +
  stat_smooth(method = "glm", 
              method.args = list(family = "binomial"),
              aes(weight = 145),
              se = TRUE, colour = "darkred") +
  labs(x = "Combined PRPF8 + Splice Site Prediction Sum", 
       y = "Proportion of Tissues with >10% PSI",
       title = "Combined Model Binomial Logistic Regression") +
  theme_minimal()
```

```{r}
# Fit binomial logistic regression
fit_length <- glm(cbind(psi_binarised_total, 145 - psi_binarised_total) ~ LENGTH,
                  data = merged, family = binomial)

# Plot
ggplot(merged, aes(x = LENGTH, y = psi_binarised_total / 145)) +
  geom_jitter(width = 0.2, height = 0.02, alpha = 0.4) +
  stat_smooth(method = "glm",
              method.args = list(family = "binomial"),
              aes(weight = 145),
              se = TRUE, colour = "steelblue") +
  labs(x = "Length",
       y = "Proportion PSI Binarised (0–1)",
       title = "Binomial Logistic Regression: Length vs PSI") +
  theme_minimal()
```
```{r}
# Fit binomial logistic regression on splice_overlap_count
fit_splice <- glm(
  cbind(psi_binarised_total, failures) ~ splice_overlap_count,
  data = merged, family = binomial
)

# Plot splice‐site count model
ggplot(merged, aes(
      x = splice_overlap_count,
      y = psi_binarised_total / 145
    )) +
  geom_jitter(width = 0.2, height = 0.02, alpha = 0.4) +
  stat_smooth(
    method = "glm",
    method.args = list(family = "binomial"),
    aes(weight = 145),
    se = TRUE, colour = "salmon"
  ) +
  labs(
    x     = "Number of Splice‐site Predictions per Intron",
    y     = "Proportion of Tissues with >10% PSI",
    title = "Binomial Logistic Regression: Splice‐site Count vs PSI"
  ) +
  theme_minimal()

```
```{r}
# First model with predict_overlap_sum
fit_overlap <- glm(cbind(psi_binarised_total, 145 - psi_binarised_total) ~ predict_overlap_sum,
                   data = merged, family = binomial)

# Calculate McFadden pseudo R²
pseudo_r2 <- function(model) {
  1 - (logLik(model) / logLik(update(model, . ~ 1)))
}

cat("AIC (overlap):", AIC(fit_overlap), "\n")
cat("McFadden R² (overlap):", round(pseudo_r2(fit_overlap), 4), "\n\n")

cat("AIC (length):", AIC(fit_length), "\n")
cat("McFadden R² (length):", round(pseudo_r2(fit_length), 4), "\n")

cat("AIC (splice count):", AIC(fit_splice), "\n")
cat("McFadden R² (splice count):", round(pseudo_r2(fit_splice), 4), "\n")
```

```{r}
# Check if splice predictions fit better if we weight their value using signal strength by summing column 5
summary_splice_score <- as.data.frame(hits_splice) %>%
  mutate(score = splice$V5[subjectHits]) %>%
  group_by(queryHits) %>%
  summarise(splice_score_sum = sum(score, na.rm = TRUE),
            .groups = "drop")

# Inject into merged
merged$splice_score_sum <- 0
merged$splice_score_sum[summary_splice_score$queryHits] <- summary_splice_score$splice_score_sum
merged <- merged %>% relocate(splice_score_sum, .after = predict_overlap_sum)

# Fit binomial model on summed scores
fit_splice_score <- glm(cbind(psi_binarised_total, failures) ~ splice_score_sum,
                        data = merged, family = binomial)

# Plot summed-score effect
ggplot(merged, aes(x = splice_score_sum, y = psi_binarised_total/145)) +
  geom_jitter(width = 0.2, height = 0.02, alpha = 0.4) +
  stat_smooth(method = "glm",
              method.args = list(family = "binomial"),
              aes(weight = 145),
              se = TRUE, colour = "turquoise") +
  labs(x     = "Sum of Splice‐site V5 Scores per Intron",
       y     = "Proportion of Tissues with >10% PSI",
       title = "Binomial Logistic Regression: Splice‐site Score vs PSI") +
  theme_minimal()

# Compare fit stats
cat("AIC (splice score):", AIC(fit_splice_score), "\n")
cat("McFadden R² (splice score):", round(pseudo_r2(fit_splice_score), 4), "\n")

```

```{r}

ggplot(merged, aes(x = factor(CLUSTER), y = LENGTH, fill = factor(CLUSTER))) +
    geom_violin(trim = FALSE, scale = "width", colour = "black", alpha = 0.7) +
    geom_boxplot(width = 0.1, outlier.shape = NA, fill = "white", colour = "black") +
    scale_y_log10() +
    scale_fill_brewer(palette = "Set2", name = "Cluster") +
    labs(
        title = "Intron length does not influence PSI cluster identity",
        x = "Intron retention category",
        y = "Base pair length (log scale)"
    ) +
    theme_minimal(base_size = 14) +
    theme(legend.position = "none")
```

```{r}
ggplot(merged, aes(x = factor(CLUSTER), y = LENGTH, fill = factor(CLUSTER))) +
    geom_violin(trim = FALSE, scale = "width", colour = "black", alpha = 0.7) +
    geom_boxplot(width = 0.1, outlier.shape = NA, fill = "white", colour = "black") +
    scale_fill_brewer(palette = "Set2", name = "Cluster") +
    labs(
        title = "Intron length does not influence PSI cluster identity",
        x = "Intron retention category",
        y = "Base pair length (log scale)"
    ) +
    coord_cartesian(ylim = c(0, 25000)) +
    theme_minimal(base_size = 14) +
    theme(legend.position = "none")
```

```{r}
library(data.table)
library(dplyr)
library(tidyr)


# Step 1: Select all *_PSI columns and compute row means
psi_cols <- grep("_PSI$", colnames(merged), value = TRUE)

merged$mean_PSI <- rowMeans(merged[, ..psi_cols], na.rm = TRUE)

# Step 2: Binary transposon presence
trans_binary <- merged[, 30:38] %>%
  mutate(across(everything(), ~ ifelse(is.na(.) | . == "", 0, 1)))

# Rename illegal column name
colnames(trans_binary)[colnames(trans_binary) == "Retroposon/SVA"] <- "Retroposon_SVA"

# Step 3: Combine into model input
merged_for_lm <- bind_cols(mean_PSI = merged$mean_PSI, trans_binary) %>%
  drop_na(mean_PSI)

# Step 4: Linear regression
model_lm <- lm(mean_PSI ~ sine + line + dna + ltr + Retroposon_SVA +
                          satellite + Low_complexity + Simple_repeat + rna,
               data = merged_for_lm)

summary(model_lm)

```
### OLD SCRIPT BELOW THIS SECTION ###
 ###                               ###
  ###                               ###
   ###                               ###
  ###                               ###
 ###                               ###
###                               ###
 ###                               ###
  ###                               ###
   ###                               ###
  ###                               ###
 ###                               ###
###                               ###
 ###                               ###
  ###                               ###
   ###                               ###
  ###                               ###
 ###                               ###
###                               ###
 ###                               ###
  ###                               ###
   ###                               ###
  ###                               ###
 ###                               ###
###                               ###
 ###                               ###
  ###                               ###
   ###                               ###
  ###                               ###
 ###                               ###

```{r
library(dplyr)

# Define transposon columns by name
transposon_cols <- colnames(merged)[29:37]

# Clean and summarise
summary_table <- merged %>%
  mutate(across(all_of(transposon_cols), ~ ifelse(is.na(.) | . == "", 0, 1))) %>%
  group_by(CLUSTER) %>%
  summarise(across(all_of(transposon_cols), sum))


```

```{r
# Step 1: Count total entries per CLUSTER
cluster_sizes <- merged %>%
  group_by(CLUSTER) %>%
  summarise(cluster_total = n())

# Step 2: Get transposon sums per CLUSTER
transposon_sums <- merged %>%
  mutate(across(all_of(transposon_cols), ~ ifelse(is.na(.) | . == "", 0, 1))) %>%
  group_by(CLUSTER) %>%
  summarise(across(all_of(transposon_cols), sum, .names = "sum_{.col}"))

# Step 3: Join totals and compute proportions (overrepresentation)
transposon_enrichment <- left_join(transposon_sums, cluster_sizes, by = "CLUSTER") %>%
  mutate(across(starts_with("sum_"), ~ . / cluster_total, .names = "rel_{.col}"))
```

```{r
library(dplyr)
library(tidyr)

# Step 1: Transposon column names (from merged)
transposon_cols <- colnames(merged)[29:37]

# Step 2: Binarise transposon presence
merged_bin <- merged %>%
  mutate(across(all_of(transposon_cols), ~ ifelse(is.na(.) | . == "", 0, 1)))

# Step 3: Total number of rows
total_n <- nrow(merged_bin)

# Step 4: Global frequency of each transposon
global_freq <- colMeans(merged_bin[, ..transposon_cols])

# Step 5: Get observed counts per CLUSTER
observed <- merged_bin %>%
  group_by(CLUSTER) %>%
  summarise(across(all_of(transposon_cols), sum), .groups = "drop")

# Step 6: Get cluster sizes
cluster_sizes <- merged_bin %>%
  count(CLUSTER, name = "cluster_total")

# Step 7: Manually calculate expected counts
# Create a data frame where each expected count = cluster size × global freq
expected <- cluster_sizes %>%
  rowwise() %>%
  mutate(expected = list(cluster_total * global_freq)) %>%
  unnest_wider(expected, names_sep = "_") %>%
  rename_with(~ paste0("exp_", transposon_cols), starts_with("expected_"))

# Step 8: Pivot both tables to long format
observed_long <- pivot_longer(observed, -CLUSTER, names_to = "transposon", values_to = "observed")
expected_long <- pivot_longer(expected, -CLUSTER, names_to = "transposon", values_to = "expected") %>%
  mutate(transposon = sub("^exp_", "", transposon))

# Step 9: Join and compute over/underrepresentation
enrichment <- left_join(observed_long, expected_long, by = c("CLUSTER", "transposon")) %>%
  mutate(deviation = observed - expected,
         enrichment_score = deviation / expected)

enrichment$enrichment_score <- format(enrichment$enrichment_score, scientific = FALSE)

```

```{r
# Use the same PSI column detection
psi_cols <- grep("_PSI$", colnames(merged), value = TRUE)

# Compute median PSI per intron
merged$median_PSI <- apply(merged[, ..psi_cols], 1, median, na.rm = TRUE)

# Binary transposon matrix
trans_binary <- merged[, 29:37] %>%
  mutate(across(everything(), ~ ifelse(is.na(.) | . == "", 0, 1)))

colnames(trans_binary)[colnames(trans_binary) == "Retroposon/SVA"] <- "Retroposon_SVA"

# Combine for modelling
merged_for_lm <- bind_cols(median_PSI = merged$median_PSI, trans_binary) %>%
  drop_na(median_PSI)

# Fit linear model
model_lm <- lm(median_PSI ~ sine + line + dna + ltr + Retroposon_SVA +
                           satellite + Low_complexity + Simple_repeat + rna,
               data = merged_for_lm)

summary(model_lm)

```